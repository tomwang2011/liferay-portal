diff --git a/freemarker/ext/beans/BeanModel.java b/freemarker/ext/beans/BeanModel.java
index 6df3b77..cb70c56 100644
--- a/freemarker/ext/beans/BeanModel.java
+++ b/freemarker/ext/beans/BeanModel.java
@@ -18,6 +18,9 @@ package freemarker.ext.beans;
 
 import java.beans.IndexedPropertyDescriptor;
 import java.beans.PropertyDescriptor;
+import java.lang.ref.Reference;
+import java.lang.ref.ReferenceQueue;
+import java.lang.ref.SoftReference;
 import java.lang.reflect.Field;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
@@ -27,6 +30,7 @@ import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
 
 import freemarker.core.CollectionAndSequence;
 import freemarker.core._DelayedFTLTypeDescription;
@@ -219,6 +223,59 @@ implements
         return wrapper.getClassIntrospector().get(object.getClass()).get(ClassIntrospector.GENERIC_GET_KEY) != null;
     }
     
+    private static class IdentityCacheKey {
+
+        @Override
+        public int hashCode() {
+            return _hashCode;
+        }
+
+        @Override
+        public boolean equals(Object object) {
+            IdentityCacheKey identityCacheKey = (IdentityCacheKey)object;
+
+            if (_object == identityCacheKey._object) {
+                return true;
+            }
+
+            return false;
+        }
+
+        private IdentityCacheKey(Object object) {
+            _object = object;
+
+            _hashCode = System.identityHashCode(_object);
+        }
+
+        private final int _hashCode;
+        private final Object _object;
+
+    }
+
+    private static class SoftIdentityCacheKeyReference
+        extends SoftReference<Method> {
+
+        private SoftIdentityCacheKeyReference(
+            IdentityCacheKey identityCacheKey, Method method,
+            ReferenceQueue<? super Method> referenceQueue) {
+
+            super(method, referenceQueue);
+
+            _identityCacheKey = identityCacheKey;
+        }
+
+        private final IdentityCacheKey _identityCacheKey;
+
+    }
+
+    private static final Map<IdentityCacheKey, SoftIdentityCacheKeyReference>
+        _propertyDescriptorMethods =
+            new ConcurrentHashMap
+                <IdentityCacheKey, SoftIdentityCacheKeyReference>();
+
+    private static final ReferenceQueue<Method> _referenceQueue =
+        new ReferenceQueue<Method>();
+
     private TemplateModel invokeThroughDescriptor(Object desc, Map classInfo)
         throws
         IllegalAccessException,
@@ -228,19 +285,52 @@ implements
         // See if this particular instance has a cached implementation
         // for the requested feature descriptor
 
+        SoftIdentityCacheKeyReference reference = null;
+
+        while ((reference =
+                    (SoftIdentityCacheKeyReference)
+                        _referenceQueue.poll()) != null) {
+
+            _propertyDescriptorMethods.remove(reference._identityCacheKey);
+        }
+
         if (desc instanceof PropertyDescriptor) {
-            if (desc instanceof IndexedPropertyDescriptor) {
-                IndexedPropertyDescriptor indexedPropertyDescriptor =
-                    (IndexedPropertyDescriptor)desc;
+            IdentityCacheKey identityCacheKey = new IdentityCacheKey(desc);
+
+            Reference<Method> methodReference = _propertyDescriptorMethods.get(
+                identityCacheKey);
 
-                desc = indexedPropertyDescriptor.getIndexedReadMethod();
+            Method method = null;
+
+            if (methodReference != null) {
+                method = methodReference.get();
             }
-            else {
-                PropertyDescriptor propertyDescriptor =
-                    (PropertyDescriptor)desc;
 
-                return wrapper.invokeMethod(
-                    object, propertyDescriptor.getReadMethod(), null);
+            if (method == null) {
+                if (desc instanceof IndexedPropertyDescriptor) {
+                    IndexedPropertyDescriptor indexedPropertyDescriptor =
+                        (IndexedPropertyDescriptor) desc;
+
+                    method = indexedPropertyDescriptor.getIndexedReadMethod();
+                }
+                else {
+                    PropertyDescriptor propertyDescriptor =
+                        (PropertyDescriptor)desc;
+
+                    method = propertyDescriptor.getReadMethod();
+                }
+
+                _propertyDescriptorMethods.put(
+                    identityCacheKey,
+                    new SoftIdentityCacheKeyReference(
+                        identityCacheKey, method, _referenceQueue));
+            }
+
+            if (desc instanceof IndexedPropertyDescriptor) {
+                desc = method;
+            }
+            else {
+                return wrapper.invokeMethod(object, method, null);
             }
         }
         else if (desc instanceof Field) {
